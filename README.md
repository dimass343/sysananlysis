Задача о рюкзаке (также задача о ранце) — NP-полная задача комбинаторной 
оптимизации. 
 Задача о рюкзаке — это задача оптимизации, используемая для иллюстрации как 
проблемы, так и решения. Он получил свое название от сценария, в котором человек ограничен 
в количестве предметов, которые можно поместить в рюкзак фиксированного размера. Учитывая 
набор предметов с определенным весом и ценностью, цель состоит в том, чтобы получить как 
можно больше ценности в рюкзаке с учетом ограничения веса рюкзака. 
 Задача о рюкзаке — это пример задачи комбинированной оптимизации, тема 
математики и информатики о поиске оптимального объекта среди множества объектов. Это 
проблема, которая изучается более века и является часто используемым примером задачи 
комбинаторной оптимизации, когда требуется оптимальный объект или окончательное решение, 
когда исчерпывающий поиск невозможен. Проблема может быть обнаружена в сценариях 
реальной жизни, таких как распределение ресурсов в условиях финансовых ограничений или 
даже при выборе инвестиций и портфелей. Его также можно найти в таких областях, как 
прикладная математика, теория сложности, криптография, комбинаторика и информатика. Это 
самая важная проблема в логистике. 
 В задаче о рюкзаке у заданных предметов есть как минимум два атрибута: стоимость 
предмета, которая влияет на его важность, и вес или объем предмета, который является его 
ограничивающим аспектом. Поскольку исчерпывающий поиск невозможен, можно разбить 
проблемы на более мелкие подзадачи и выполнять их рекурсивно. Такая структура называется 
оптимальной. Это относится только к одному предмету за раз и текущему весу, который все еще 
доступен в рюкзаке. Решателю проблемы нужно только решить, брать предмет или нет, исходя 
из веса, который еще можно взять. Однако, если это программа, пересчет не является 
независимым и вызовет проблемы. Здесь можно применить методы динамического 
программирования. Решения каждой подзадачи сохраняются, так что вычисление нужно 
выполнить только один раз. 
Задача о рюкзаке (также задача о ранце) — NP-полная задача комбинаторной 
оптимизации.
 Задача о рюкзаке — это пример задачи комбинированной оптимизации, тема 
математики и информатики о поиске оптимального объекта среди множества объектов. Это 
проблема, которая изучается более века и является часто используемым примером задачи 
4
комбинаторной оптимизации, когда требуется оптимальный объект или окончательное решение, 
когда исчерпывающий поиск невозможен. Проблема может быть обнаружена в сценариях 
реальной жизни, таких как распределение ресурсов в условиях финансовых ограничений или 
даже при выборе инвестиций и портфелей. Его также можно найти в таких областях, как 
прикладная математика, теория сложности, криптография, комбинаторика и информатика. Это 
самая важная проблема в логистике.
В общем виде задачу можно сформулировать так: из заданного множества предметов со 
свойствами «стоимость» и «вес» требуется отобрать подмножество с максимальной полной 
стоимостью, соблюдая при этом ограничение на суммарный вес.
5
1. Актуальность темы исследования
Классическая задача о ранце (КЗР) относится к числу широко известных задач дискретной 
оптимизации. Впервые КЗР была сформулирована Д. Данцигом и с тех пор активно исследуется; 
ее популярность, прежде всего, вызвана большим количеством приложений. Основные сферы 
применения находятся в областях планирования и управления экономическими, 
производственными и транспортными системами. В частности, следует отметить 
формулируемые в рамках КЗР задачи объемного планирования для предприятий с единичным и 
мелкосерийным характером производства и задачи загрузки транспортных средств.
Начиная с 60-70-х гг. ХХ века стали рассматриваться различные модификации КЗР. В 
частности, была изучена КЗР с дробимыми предметами и КЗР в многомерной постановке. 
Одновременно исследовались КЗР, где требование булевозначности переменных заменено 
требованием принадлежности их некоторому множеству неотрицательных целых чисел в 
ограниченном диапазоне. Встречаются также постановки КЗР с нелинейными критериями, в 
частности, сепарабельными. Введение обобщений вызвано стремлением моделировать более 
широкие классы ситуаций, возникающих в практике планирования и оперативного управления.
Наиболее существенным шагом на пути расширения практической применимости 
ранцевых моделей стало исследование задачи о ранце с несколькими критериями. Последнее 
десятилетие значительное внимание уделяется именно таким постановкам ранцевых задач. 
Можно утверждать, что все задачи, реально возникающие в системах управления по сути своей 
многокритериальны. Это объективно связано с тем, что в каждой экономической, 
производственной, транспортной системе имеется ряд участников, каждый из которых по-своему 
оценивает качество принимаемых решений. Кроме того, некоторые участники могут оценивать 
принимаемые решения по нескольким показателям. 
Реальные задачи управления и планирования (прежде всего, объемного и объемнокалендарного) для своего адекватного описания требуют расширения класса рассматриваемых 
многокритериальных ранцевых моделей, введения новых типов критериев (не всегда линейных) 
и ограничений. Решение многокритериальных задач по сравнению с однокритериальными 
сопряжено со значительными дополнительными трудностями. Это связано с необходимостью 
разработки специальных принципов оптимальности и соответствующих схем решения, а также с 
большой вычислительной сложностью указанных схем.
Актуальность исследования предопределена широкой распространенностью и важностью 
прикладных проблем, формулируемых в рамках многокритериальных задач ранцевого типа.
6
Задача имеет множество разновидностей. Наиболее популярными разновидностями 
являются следующие:
1. Рюкзак 0-1 не более одного экземпляра каждого предмета.
2. Ограниченный рюкзак : не более заданного числа экземпляров каждого 
предмета.
3. Неограниченный рюкзак : произвольное количество экземпляров каждого 
предмета.
4. Рюкзак с мультивыбором: предметы разделены на группы, и из каждой 
группы требуется выбрать только один предмет.
5. Множественный рюкзак : есть несколько рюкзаков, каждый со своим 
максимальным весом. Каждый предмет можно положить в любой рюкзак или оставить.
6. Многомерный рюкзак : вместо веса дано несколько разных ресурсов 
(например, вес, объём и время укладки). Каждый предмет тратит заданное количество 
каждого ресурса. Надо выбрать подмножество предметов так, чтобы общие затраты 
каждого ресурса не превышали максимума по этому ресурсу, и при этом общая ценность 
предметов была максимальна[4]
.
7. Квадратичная задача о рюкзаке : суммарная ценность задается 
неотрицательно определённой квадратичной формулой
Как было сказано выше, задача о рюкзаке относится к классу NP-полных, и для неё пока 
что не найден полиномиальный алгоритм, решающего её за разумное время. Поэтому при 
решении задачи о рюкзаке необходимо выбирать между точными алгоритмами, которые 
неприменимы для «больших» рюкзаков, и приближенными, которые работают быстро, но не 
гарантируют оптимального решения задачи.
Рассмотрим несколько алгоритмов решения задачи, чтобы понять какой из алгоритмов 
быстрее 
Задача о одномерном рюкзаке (0-1 knapsack) является классической задачей дискретной 
оптимизации [1],[2]. Данная задача и ее варианты широко используются для моделирования 
большого числа практических задач. В общем виде задачу можно сформулировать так: из 
заданного множества предметов со свойствами «стоимость» и «вес», требуется отобрать некое 
число предметов таким образом, чтобы получить максимальную суммарную стоимость при 
одновременном соблюдении ограничения на суммарный вес.
Более точно, пусть P(i) > 0 и W(i) > 0 – соответственно стоимость и вес i-го предмета, где i = 
1,2,3,…,N , а N– число предметов.
Требуется найти такой булев вектор X размерностью N, где
X(i) = 1, если предмет с номером i положен в рюкзак;
7
X(i) = 0, если предмет с номером i не положен в рюкзак;
чтобы была максимальной сумма Σ P(i) X(i)
и выполнялось неравенство Σ W(i) X(i) ≤ C, где C > 0 – вместимость рюкзака.
Существуют различные точные и приближенные алгоритмы решения задачи о рюкзаке.
К точным алгоритмам относятся:
• полный перебор
• метод ветвей и границ
• динамического программирования (ДП)
Приближенными алгоритмами являются жадный (ЖА) и генетический (ГА). Сравнение 
различных методов решения задачи о рюкзаке широко представлено в литературе и интернете, 
поэтому не будем на нем останавливаться и сразу перейдем к делу.
Предлагаемый ниже алгоритм можно условно рассматривать как усложнение ЖА и как 
упрощение алгоритма ДП.
Рассмотрим вариант алгоритма решения задачи о рюкзаке при условии, что веса предметов 
являются натуральными числами, а стоимости предметов являются вещественными числами.
Предположим, что нам нужно взять комплектующие для компьютера, чтобы выставить на 
продажу.
Первое число - стоимость, второе - вес. Возьмем максимальный вес рюкзака 4. С левой 
стороны у нас будут все вещи. При этом порядок в котором они расположены, в данной задаче 
нас не интересует. Количество колонок равно количеству потенциальных рюкзаков размером от 
1, минимально возможного целого положительного числа, до размера нашего рюкзака, с шагом 
1. Таким образом мы пытаемся решить ряд более мелких задач, для рюкзаков размером 1, 2, 3 и 
4 Таким образом алгоритм будет заполнять таблицу
8
Полная реализация кода на С# с входными данными для того, чтобы понять какой из 
алгоритмов будет быстрее
public static int[] weights = { };
public static int[] values = { };
public static int CountMax(int[] weights, int[] values, int maxCapacity)
{
 //строим массив и закладываем место на ячейки пустышки 
 //выходящие из левого верхнего угла
 int[,] arr = new int[weights.Length + 1, maxCapacity + 1];
 //проходим по всем вещам
 for (int i = 0; i <= weights.Length; i++)
 {
 //проходим по всем рюкзакам
 for (int j = 0; j <= maxCapacity; j++)
 {
 //попадаем в пустую ячейку
 if (i == 0 || j == 0)
 {
 arr[i, j] = 0;
 }
 else
 { 
 //если вес текущей вещи больше размера рюкзака
 //казалось бы откуда значение возьмется для первой вещи 
 //при таком условии. А оно возьмется из ряда пустышки
 if (weights[i - 1] > j)
 {
 arr[i, j] = arr[i - 1, j];
 }
 else
 {
 //здесь по формуле. Значение над текущей ячейкой
9
 var prev = arr[i - 1, j];
 //Значение по вертикали: ряд вверх
 //и по горизонтали: вес рюкзака - вес текущей вещи
 var byFormula = values[i - 1] + arr[i - 1, j - weights[i - 1]];
 arr[i, j] = Math.Max(prev, byFormula);
 }
 }
 }
 }
 // возвращаем правую нижнюю ячейку
 return arr[weights.Length, maxCapacity];
}
10
2. Жадный алгоритм.
Идея этой задачи состоит в том, чтобы вычислить коэффицент который является 
отношением цены к его весу, расположенные в порядке убывания. 
Дальше берём те вещи, у которых этот коэффициент максимален и которые помещаются 
в рюкзак. Каждый раз, когда вещь кладут в рюкзак, это уменьшает вместимость рюкзака. Способ 
выбора вещей: Рассмотрим массив коэффицентов 
Предположим, мы нашли частичное решение: (x1,...,xi). Стоимость рюкзака получается:
В соответствии с весом упаковок, положенных в рюкзак:
Следовательно, остаточный предел веса рюкзака составляет: 
11
2.1 Шаги алгоритма
Шаг 1: Корень узла представляет начальное состояние рюкзака, в котором вы не выбрали 
ни одного пакета. Общее значение = 0. Верхняя граница корневого узла UpperBound = M * 
Максимальная стоимость единицы.
Шаг 2: Корень узла будет иметь дочерние узлы, соответствующие возможности выбора 
пакета с наибольшей удельной стоимостью. Для каждого узла нужно пересчитать параметры: 
TotalValue = TotalValue (старый) + количество выбранных пакетов * стоимость каждого пакета. 
M = M (old) – количество выбранных пакетов * вес каждого пакета. UpperBound = TotalValue + 
M (новый) * Стоимость единицы упаковки, которая будет рассматриваться далее. 
Шаг 3: В дочерних узлах нужно отдавать приоритет ветвлению для узла, имеющего 
большую верхнюю границу. Потомки этого узла соответствуют возможности выбора 
следующего пакета, имеющего большую удельную стоимость. Для каждого узла необходимо 
пересчитать параметры TotalValue, M, UpperBound по формуле, указанной в шаге 2. 
Шаг 4: Повторите шаг 3 с примечанием: для узлов с верхней границей ниже или равных 
значениям временной максимальной стоимости найденного варианта вам больше не нужно 
переходить к этому узлу.
Шаг 5: Если все узлы разветвлены или отрезаны, самый дорогой вариант — тот, 
который нужно искать.
Сортировка для последовательного выбора займёт O(N*log(N)) плюс проход по массиву. 
O(N*log(N))+O(N) но в общем случае O(N*log(N)).
12
3. Метод ветвей и границ.
Мы определяем функцию стоимости как сумму vifi, так что общее значение является 
максимальным, которое может быть получено, которое меньше или равно W. Здесь fi указывает 
долю объекта, которая должна быть включена. Хотя здесь мы используем дроби, они не 
включены в окончательное решение.
Здесь процедура решения проблемы выглядит следующим образом: 
Вычислите функцию стоимости и верхнюю границу для двух дочерних элементов 
каждого узла. Здесь (i + 1)-й уровень указывает, должен ли быть включен i-й объект или нет. Если 
функция стоимости для данного узла больше, чем верхняя граница, то узел не нужно исследовать 
дальше. Следовательно, мы можем убить этот узел. В противном случае вычислите верхнюю 
границу для этого узла. Если это значение меньше U, то нужно заменить значение U этим 
значением. Затем удалить все неисследованные узлы, у которых функция стоимости больше 
этого значения. Следующим проверяемым узлом после достижения всех узлов определенного 
уровня будет узел с наименьшим значением функции стоимости среди неисследованных узлов. 
При включении объекта необходимо проверить, не превысило ли добавление объекта пороговое 
значение. Если это так, то вы достигли конечной точки в этой ветви, и все последующие объекты 
не будут включены. Таким образом, мы найдем значение U в конце, которое исключает все 
другие возможности. Путь к этому узлу определит решение этой проблемы.
Несмотря на то, что этот метод более эффективен, чем другие решения этой задачи, его 
сложность в наихудшем случае по-прежнему составляет в тех случаях, когда 
необходимо исследовать все дерево. Однако в лучшем случае придется исследовать только один 
путь через дерево, и, следовательно, его временная сложность в лучшем случае равна O (n). 
Поскольку этот метод требует создания дерева пространства состояний, его пространственная 
сложность также будет экспоненциальной.
Рассмотрим задачу с n = 4, V = {10, 10, 12, 18}, w = {2, 4, 6, 9} и W = 15. Здесь мы 
вычисляем начальную верхнюю границу как U = 10 + 10 + 12 = 32. Нужно обратить внимание, 
что сюда нельзя включить 4-й объект, так как он превысит W. К стоимости мы добавляем 3/9 
конечного значения, и, следовательно, функция стоимости равна 38. После расчета стоимости в 
каждом нужно отсечь пути, которые не нуждаются в исследовании. Следовательно, конечное 
13
дерево пространства состояний будет следующим (Здесь номер узла обозначает порядок, в 
котором было исследовано дерево пространства состояний):
14
4. Сравнительная характеристика методов.
Для сравнительной характеристики программа была изменена для проверки на больших 
количествах вещей и больших числах. Это сделано для того, чтобы выполнить более точное 
сравнение по времени (на маленьких тестах слишком быстрое выполнение). Получил таблицу:
15
Заключение
Рассмотренные алгоритмы различны по своей идее по своей реализации и степени 
надёжности. И соответственно, каждый алгоритм подходит к разным задачам или ТЗ. Так, 
Перебор может пригодиться тогда, когда нужно оперативное решение задачи, когда есть чуть 
больше времени можно улучшить перебор, превратив его в метод ветвей и границ (не забываем 
также, что это самые мало затратные по памяти способы). Если есть ещё больше времени и 
большей критике подвергается время выполнения, то оптимальным будет динамическое 
программирование. Если крайне критично время выполнения, но ответ не обязательно нужен 
лучший (просто какой-нибудь ответ, удовлетворяющий условиям и не последний по стоимости) 
то жадный алгоритм — это ваш выбор
